## 环境
### php7+

## 设计模式
### 1 简单工厂模式
    测试：php single_factory/test.php
    场景：
    1）多种支付场景，支付宝、微信、银行卡等等
    优点：
    1）工厂类中包含逻辑判断，去除与客户端依赖
    说明：
    1）内部逻辑判断在工厂类中实现
    2）增加产品时需增加工厂类内部逻辑判断
### 2 工厂方法模式
    测试：php factory_method/test.php
    优点：
    1）遵守开放-封闭原则，可扩展，不修改
    说明：
    1）内部逻辑判断在客户端实现
    2）增加产品时需增加工厂子类
    3）工厂模式一般配合反射使用，不用进行条件判断
### 3 抽象工厂模式    
### 4 策略模式
    测试：php strategy/test.php
    场景：
    1）商品活动促销，打几折、满减
    优点：
    1）策略选取由客户端承担，并转给Context对象实现，减轻客户端职责
    说明：
    1）必须有Context类，通过构造函数参数传递的类型生成具体的算法
    2）如果想去除Context中的switch，可配合反射，不用进行条件判断
    3）策略模式用来封装算法，可以用来封装几乎任何类型的规则
### 5 装饰模式
    测试：php decorator/test.php
    场景：
    1）服饰系统QQ秀
    优点：
    1）可以在原来功能上动态添加新功能
    2）分离核心功能与装饰功能，装饰类不会增加核心类的复杂度
    说明：
    1）装饰类是在已有类上增加新功能
    2）装饰类一般为了满足特定某种特定情况下才会执行的行为的需要
    3）装饰模式的装饰顺序很重要，最好保证装饰类间彼此独立
### 6 代理模式
    测试：php proxy/test.php
    场景：
    1）当对象需要有不同权限时，用来控制对真实对象访问时的权限
    2）在调用真实对象时，额外做其他事
    优点：
    1）可以为不同代理分配不同的权限，且不用知道真实对象
    说明：
    1）代理是控制对真实对象的访问
### 7 原型模式 （原型类声明一个克隆自身的接口）
    测试：php prototype/test.php
    场景：
    1）需要深复制或浅复制场合（浅复制对对象只是复制引用，还是指向原有对象。深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象）    
    说明：
    1）从一个对象再创建一个可定制的对象，而不需要知道任何创建的细节
    2）不用重新初始化对象，而是动态的获得对象运行时的状态
### 8 模版方法模式
    测试：php template_method/test.php
    场景：
    1）考试试卷与答案，试卷应提取为模版
    优点：
    1）通过把不变行为搬移到超类，去除子类中的重复代码
    说明：
    1）模版方法模式是定义一个操作中的算法的骨架，而将具体步骤延迟到子类中实现
### 9 外观模式
    测试：php facade/test.php
    场景：
    1）设计初期，对系统进行分层，如MVC架构
    2）开发阶段，子系统越来越复杂，增加外观可以提供一个简单的接口，减少依赖
    3）维护遗留大型系统，该系统可能难以维护及扩展。增加新需求可以增加外观与遗留代码交互所有复杂的工作
    说明：
    1）外观模式为子系统的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得子系统容易使用 
## 设计原则
### 1 单一职责原则
    解释：就一个类而言，应该仅有一个引起它变化的原因
    场景：
    1）方块游戏，应把游戏逻辑与界面显示分离出来
### 2 开放封闭原则
    解释：软件实体（类、模块、函数）对扩展开放，对修改封闭
    场景：
    1）当可能发送变化时，创建一个抽象类，不会更改现有的代码，最好在变化发送时创建
    2）工厂方法模式遵守开放封闭原则
### 3 依赖倒转原则
    解释：高层模块不应该依赖低层模块，两个都应该依赖抽象。
    针对接口编程，而非实现，程序中所有的依赖关系都是终止于抽象类或接口
    场景：
    1）使用多种数据库，model顶层都应该抽象为接口，每种数据库各自实现接口
### 4 迪米特法则
    解释：每一个类都应当尽量降低成员的访问权限

    