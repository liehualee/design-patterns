## 环境
### php7+

## 设计模式
### 1 简单工厂模式
    测试：php single_factory/test.php
    场景：
    1）多种支付场景，支付宝、微信、银行卡等等
    优点：
    1）工厂类中包含逻辑判断，去除与客户端依赖
    说明：
    1）内部逻辑判断在工厂类中实现
    2）增加产品时需增加工厂类内部逻辑判断
### 2 工厂方法模式
    测试：php factory_method/test.php
    优点：
    1）遵守开放-封闭原则，可扩展，不修改
    说明：
    1）内部逻辑判断在客户端实现
    2）增加产品时需增加工厂子类
    3）工厂模式一般配合反射使用，不用进行条件判断
### 3 抽象工厂模式    
    测试：php abstract_factory/test.php
    工厂方法与抽象工厂区别：
    1）工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个
    2）工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个
    工厂方法模式：
    一个抽象产品类，可以派生出多个具体产品类
    一个抽象工厂类，可以派生出多个具体工厂类
    每个具体工厂类只能创建一个具体产品类的实例
    抽象工厂模式：
    多个抽象产品类，每个抽象产品类可以派生出多个具体产品类
    一个抽象工厂类，可以派生出多个具体工厂类
    每个具体工厂类可以创建多个具体产品类的实例
### 4 策略模式
    测试：php strategy/test.php
    场景：
    1）商品活动促销，打几折、满减
    优点：
    1）策略选取由客户端承担，并转给Context对象实现，减轻客户端职责
    说明：
    1）必须有Context类，通过构造函数参数传递的类型生成具体的算法
    2）如果想去除Context中的switch，可配合反射，不用进行条件判断
    3）策略模式用来封装算法，可以用来封装几乎任何类型的规则
### 5 装饰模式
    测试：php decorator/test.php
    场景：
    1）服饰系统QQ秀
    优点：
    1）可以在原来功能上动态添加新功能
    2）分离核心功能与装饰功能，装饰类不会增加核心类的复杂度
    说明：
    1）装饰类是在已有类上增加新功能
    2）装饰类一般为了满足特定某种特定情况下才会执行的行为的需要
    3）装饰模式的装饰顺序很重要，最好保证装饰类间彼此独立
### 6 代理模式
    测试：php proxy/test.php
    场景：
    1）当对象需要有不同权限时，用来控制对真实对象访问时的权限
    2）在调用真实对象时，额外做其他事
    优点：
    1）可以为不同代理分配不同的权限，且不用知道真实对象
    说明：
    1）代理是控制对真实对象的访问
### 7 原型模式 （原型类声明一个克隆自身的接口）
    测试：php prototype/test.php
    场景：
    1）需要深复制或浅复制场合（浅复制对对象只是复制引用，还是指向原有对象。深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象）    
    说明：
    1）从一个对象再创建一个可定制的对象，而不需要知道任何创建的细节
    2）不用重新初始化对象，而是动态的获得对象运行时的状态
### 8 模版方法模式
    测试：php template_method/test.php
    场景：
    1）考试试卷与答案，试卷应提取为模版
    优点：
    1）通过把不变行为搬移到超类，去除子类中的重复代码
    说明：
    1）模版方法模式是定义一个操作中的算法的骨架，而将具体步骤延迟到子类中实现
### 9 外观模式
    测试：php facade/test.php
    场景：
    1）设计初期，对系统进行分层，如MVC架构
    2）开发阶段，子系统越来越复杂，增加外观可以提供一个简单的接口，减少依赖
    3）维护遗留大型系统，该系统可能难以维护及扩展。增加新需求可以增加外观与遗留代码交互所有复杂的工作
    说明：
    1）外观模式为子系统的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得子系统容易使用 
### 10 建造者模式
    测试：php builder/test.php
    场景：
    1）用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临复杂的变化
    优点：
    1）使建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以
    说明：
    1）建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式   
### 11 观察者模式（发布-订阅模式）
    测试：php observer/test.php
    场景：
    1）当一个对象的改变需要同时改变其他多个对象时候
    说明：
    1）观察者模式定义了一种一对多依赖关系，让多个观察者对象同时监听某一个主题对象
    2）一般用事件委托方式改进观察者模式，观察者方法名可自定义，但必须具有相同的参数列表和返回值类型 
### 12 状态模式
    测试：php state/test.php
    场景：
    1）一个对象的行为取决于它的状态，状态的变化都是依靠大量的多分支判断语句来实现，每种状态可定义为一个State的子类
    说明：
    1）状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况
    2）把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化 
### 13 适配器模式
    测试：php adapter/test.php
    场景：
    1）两个类所做的事情相同或相似，但是具有不同的接口
    2）接口双方不太容易修改的时候可使用适配器模式 
    说明：
    1）将一个类的接口转换为客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的类可以一起工作
    2）只有碰到无法改变原有设计和代码的情况下，才考虑用适配器模式
### 14 备忘录模式
    测试：php memento/test.php
    场景：
    1）游戏进度备忘
    2）实现撤销功能，如命令模式的撤销功能
    缺点：
    1）状态需要完整存储到备忘录对象中，如果状态数据很大很多，备忘录对象会非常耗内存
    说明：
    1）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个对象。
### 15 组合模式
    测试：php composite/test.php 
    场景：
    1）需求体现部分与整体结构，且可以被一致对待
    2）公司-分公司-办事处-部门
    优点：
    1）组合模式可以让客户可以一致地使用结构和单个对象
    说明：
    1）组合模式，将对象组合成树形结构以表示部分整体的层次结构
    2）组合模式使得用户对单个对象和组合对象的使用具有一致性  
### 16 迭代器模式
    测试：php iterator/test.php 
    场景：
    1）聚合对象需要遍历，或需要有多种方式遍历
    2）访问数组、集合、列表或数据库数据操作
    说明：
    1）迭代器模式，提供一个方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示
    2）迭代器模式分离了集合对象的遍历行为，抽象出一个迭代类来负责，这样可以不暴露集合的内部结构，又可让外部代码透明的访问集合内部的数据
### 17 单例模式
    测试：php singleton/test.php
    场景：
    1）获取对象的唯一实例   
    说明：
    1）单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点
    2）三私一公构成 
### 18 桥接模式
    测试：php bridge/test.php    
    场景：
    1）实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少耦合
    说明：
    1）桥接模式，将抽象部分与它的实现部分分离，使它们都可以独立的变化
    2）桥接模式遵循合成/聚合复用原则，尽量使用合成/聚合，尽量不要使用类继承
### 19 命令模式
    测试：php command/test.php  
    场景：
    1）任务消息队列
    优点：
    1）能较容易的设计一个命令队列
    2）在需要的情况下，能较容易的将命令记入日志
    3）允许接收请求的一方决定是否要否决请求
    4）可以容易实现对请求的撤销和重做
    5）由于加入新的具体命令类不影响其他的类，增加新的具体命令类很容易 
    6）命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开
    说明：
    1）命令模式，将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化
    2）可对请求排队或记录请求日志，以及支持可撤销的操作     
## 设计原则
### 1 单一职责原则
    解释：就一个类而言，应该仅有一个引起它变化的原因
    场景：
    1）方块游戏，应把游戏逻辑与界面显示分离出来
### 2 开放封闭原则
    解释：软件实体（类、模块、函数）对扩展开放，对修改封闭
    场景：
    1）当可能发送变化时，创建一个抽象类，不会更改现有的代码，最好在变化发送时创建
    2）工厂方法模式遵守开放封闭原则
### 3 依赖倒转原则
    解释：高层模块不应该依赖低层模块，两个都应该依赖抽象。
    针对接口编程，而非实现，程序中所有的依赖关系都是终止于抽象类或接口
    场景：
    1）使用多种数据库，model顶层都应该抽象为接口，每种数据库各自实现接口
### 4 迪米特法则
    解释：每一个类都应当尽量降低成员的访问权限

    