## 设计模式
### 1 简单工厂模式
    测试：php single_factory/test.php
    场景：
    1）多种支付场景，支付宝、微信、银行卡等等
    优点：
    1）工厂类中包含逻辑判断，去除与客户端依赖
    说明：
    1）内部逻辑判断在工厂类中实现
    2）增加产品时需增加工厂类内部逻辑判断
### 2 工厂方法模式
    测试：php factory_method/test.php
    优点：
    1）遵守开放-封闭原则，可扩展，不修改
    说明：
    1）内部逻辑判断在客户端实现
    2）增加产品时需增加工厂子类
    3）工厂模式一般配合反射使用，不用进行条件判断
### 3 抽象工厂模式    
### 4 策略模式
    测试：php strategy/test.php
    场景：
    1）商品活动促销，打几折、满减
    优点：
    1）策略选取由客户端承担，并转给Context对象实现，减轻客户端职责
    说明：
    1）必须有Context类，通过构造函数参数传递的类型生成具体的算法
    2）如果想去除Context中的switch，可配合反射，不用进行条件判断
    3）策略模式用来封装算法，可以用来封装几乎任何类型的规则
### 5 装饰模式
    测试：php decorator/test.php
    场景：
    1）服饰系统QQ秀
    优点：
    1）可以在原来功能上动态添加新功能
    2）分离核心功能与装饰功能，装饰类不会增加核心类的复杂度
    说明：
    1）装饰类是在已有类上增加新功能
    2）装饰类一般为了满足特定某种特定情况下才会执行的行为的需要
    3）装饰模式的装饰顺序很重要，最好保证装饰类间彼此独立
### 6 代理模式
    测试：php proxy/test.php
    场景：
    1）当对象需要有不同权限时，用来控制对真实对象访问时的权限
    2）在调用真实对象时，额外做其他事
    优点：
    1）可以为不同代理分配不同的权限，且不用知道真实对象
    说明：
    1）代理是控制对真实对象的访问
## 设计原则
### 1 单一职责原则
    解释：就一个类而言，应该仅有一个引起它变化的原因
    场景：
    1）方块游戏，应把游戏逻辑与界面显示分离出来
### 2 开放封闭原则
    解释：软件实体（类、模块、函数）对扩展开放，对修改封闭
    场景：
    1）当可能发送变化时，创建一个抽象类，不会更改现有的代码，最好在变化发送时创建
    2）工厂方法模式遵守开放封闭原则
### 3 依赖倒转原则
    解释：高层模块不应该依赖低层模块，两个都应该依赖抽象。
    针对接口编程，而非实现，程序中所有的依赖关系都是终止于抽象类或接口
    场景：
    1）使用多种数据库，model顶层都应该抽象为接口，每种数据库各自实现接口
### 4 迪米特法则

    